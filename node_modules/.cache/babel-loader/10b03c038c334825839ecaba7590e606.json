{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useAccessibility;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _KeyCode = _interopRequireDefault(require(\"rc-util/lib/KeyCode\"));\n\nvar _raf = _interopRequireDefault(require(\"rc-util/lib/raf\"));\n\nvar _focus = require(\"rc-util/lib/Dom/focus\");\n\nvar _IdContext = require(\"../context/IdContext\"); // destruct to reduce minify size\n\n\nvar LEFT = _KeyCode.default.LEFT,\n    RIGHT = _KeyCode.default.RIGHT,\n    UP = _KeyCode.default.UP,\n    DOWN = _KeyCode.default.DOWN,\n    ENTER = _KeyCode.default.ENTER,\n    ESC = _KeyCode.default.ESC;\nvar ArrowKeys = [UP, DOWN, LEFT, RIGHT];\n\nfunction getOffset(mode, isRootLevel, isRtl, which) {\n  var _inline, _horizontal, _vertical, _offsets$;\n\n  var prev = 'prev';\n  var next = 'next';\n  var children = 'children';\n  var parent = 'parent'; // Inline enter is special that we use unique operation\n\n  if (mode === 'inline' && which === ENTER) {\n    return {\n      inlineTrigger: true\n    };\n  }\n\n  var inline = (_inline = {}, (0, _defineProperty2.default)(_inline, UP, prev), (0, _defineProperty2.default)(_inline, DOWN, next), _inline);\n  var horizontal = (_horizontal = {}, (0, _defineProperty2.default)(_horizontal, LEFT, isRtl ? next : prev), (0, _defineProperty2.default)(_horizontal, RIGHT, isRtl ? prev : next), (0, _defineProperty2.default)(_horizontal, DOWN, children), (0, _defineProperty2.default)(_horizontal, ENTER, children), _horizontal);\n  var vertical = (_vertical = {}, (0, _defineProperty2.default)(_vertical, UP, prev), (0, _defineProperty2.default)(_vertical, DOWN, next), (0, _defineProperty2.default)(_vertical, ENTER, children), (0, _defineProperty2.default)(_vertical, ESC, parent), (0, _defineProperty2.default)(_vertical, LEFT, isRtl ? children : parent), (0, _defineProperty2.default)(_vertical, RIGHT, isRtl ? parent : children), _vertical);\n  var offsets = {\n    inline: inline,\n    horizontal: horizontal,\n    vertical: vertical,\n    inlineSub: inline,\n    horizontalSub: vertical,\n    verticalSub: vertical\n  };\n  var type = (_offsets$ = offsets[\"\".concat(mode).concat(isRootLevel ? '' : 'Sub')]) === null || _offsets$ === void 0 ? void 0 : _offsets$[which];\n\n  switch (type) {\n    case prev:\n      return {\n        offset: -1,\n        sibling: true\n      };\n\n    case next:\n      return {\n        offset: 1,\n        sibling: true\n      };\n\n    case parent:\n      return {\n        offset: -1,\n        sibling: false\n      };\n\n    case children:\n      return {\n        offset: 1,\n        sibling: false\n      };\n\n    default:\n      return null;\n  }\n}\n\nfunction findContainerUL(element) {\n  var current = element;\n\n  while (current) {\n    if (current.getAttribute('data-menu-list')) {\n      return current;\n    }\n\n    current = current.parentElement;\n  } // Normally should not reach this line\n\n  /* istanbul ignore next */\n\n\n  return null;\n}\n/**\n * Find focused element within element set provided\n */\n\n\nfunction getFocusElement(activeElement, elements) {\n  var current = activeElement || document.activeElement;\n\n  while (current) {\n    if (elements.has(current)) {\n      return current;\n    }\n\n    current = current.parentElement;\n  }\n\n  return null;\n}\n/**\n * Get focusable elements from the element set under provided container\n */\n\n\nfunction getFocusableElements(container, elements) {\n  var list = (0, _focus.getFocusNodeList)(container, true);\n  return list.filter(function (ele) {\n    return elements.has(ele);\n  });\n}\n\nfunction getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1; // Key on the menu item will not get validate parent container\n\n  if (!parentQueryContainer) {\n    return null;\n  } // List current level menu item elements\n\n\n  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements); // Find next focus index\n\n  var count = sameLevelFocusableMenuElementList.length;\n  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function (ele) {\n    return focusMenuElement === ele;\n  });\n\n  if (offset < 0) {\n    if (focusIndex === -1) {\n      focusIndex = count - 1;\n    } else {\n      focusIndex -= 1;\n    }\n  } else if (offset > 0) {\n    focusIndex += 1;\n  }\n\n  focusIndex = (focusIndex + count) % count; // Focus menu item\n\n  return sameLevelFocusableMenuElementList[focusIndex];\n}\n\nfunction useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {\n  var rafRef = React.useRef();\n  var activeRef = React.useRef();\n  activeRef.current = activeKey;\n\n  var cleanRaf = function cleanRaf() {\n    _raf.default.cancel(rafRef.current);\n  };\n\n  React.useEffect(function () {\n    return function () {\n      cleanRaf();\n    };\n  }, []);\n  return function (e) {\n    var which = e.which;\n\n    if ([].concat(ArrowKeys, [ENTER, ESC]).includes(which)) {\n      // Convert key to elements\n      var elements;\n      var key2element;\n      var element2key; // >>> Wrap as function since we use raf for some case\n\n      var refreshElements = function refreshElements() {\n        elements = new Set();\n        key2element = new Map();\n        element2key = new Map();\n        var keys = getKeys();\n        keys.forEach(function (key) {\n          var element = document.querySelector(\"[data-menu-id='\".concat((0, _IdContext.getMenuId)(id, key), \"']\"));\n\n          if (element) {\n            elements.add(element);\n            element2key.set(element, key);\n            key2element.set(key, element);\n          }\n        });\n        return elements;\n      };\n\n      refreshElements(); // First we should find current focused MenuItem/SubMenu element\n\n      var activeElement = key2element.get(activeKey);\n      var focusMenuElement = getFocusElement(activeElement, elements);\n      var focusMenuKey = element2key.get(focusMenuElement);\n      var offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which); // Some mode do not have fully arrow operation like inline\n\n      if (!offsetObj) {\n        return;\n      } // Arrow prevent default to avoid page scroll\n\n\n      if (ArrowKeys.includes(which)) {\n        e.preventDefault();\n      }\n\n      var tryFocus = function tryFocus(menuElement) {\n        if (menuElement) {\n          var focusTargetElement = menuElement; // Focus to link instead of menu item if possible\n\n          var link = menuElement.querySelector('a');\n\n          if (link === null || link === void 0 ? void 0 : link.getAttribute('href')) {\n            focusTargetElement = link;\n          }\n\n          var targetKey = element2key.get(menuElement);\n          triggerActiveKey(targetKey);\n          /**\n           * Do not `useEffect` here since `tryFocus` may trigger async\n           * which makes React sync update the `activeKey`\n           * that force render before `useRef` set the next activeKey\n           */\n\n          cleanRaf();\n          rafRef.current = (0, _raf.default)(function () {\n            if (activeRef.current === targetKey) {\n              focusTargetElement.focus();\n            }\n          });\n        }\n      };\n\n      if (offsetObj.sibling || !focusMenuElement) {\n        // ========================== Sibling ==========================\n        // Find walkable focus menu element container\n        var parentQueryContainer;\n\n        if (!focusMenuElement || mode === 'inline') {\n          parentQueryContainer = containerRef.current;\n        } else {\n          parentQueryContainer = findContainerUL(focusMenuElement);\n        } // Get next focus element\n\n\n        var targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset); // Focus menu item\n\n        tryFocus(targetElement); // ======================= InlineTrigger =======================\n      } else if (offsetObj.inlineTrigger) {\n        // Inline trigger no need switch to sub menu item\n        triggerAccessibilityOpen(focusMenuKey); // =========================== Level ===========================\n      } else if (offsetObj.offset > 0) {\n        triggerAccessibilityOpen(focusMenuKey, true);\n        cleanRaf();\n        rafRef.current = (0, _raf.default)(function () {\n          // Async should resync elements\n          refreshElements();\n          var controlId = focusMenuElement.getAttribute('aria-controls');\n          var subQueryContainer = document.getElementById(controlId); // Get sub focusable menu item\n\n          var targetElement = getNextFocusElement(subQueryContainer, elements); // Focus menu item\n\n          tryFocus(targetElement);\n        }, 5);\n      } else if (offsetObj.offset < 0) {\n        var keyPath = getKeyPath(focusMenuKey, true);\n        var parentKey = keyPath[keyPath.length - 2];\n        var parentMenuElement = key2element.get(parentKey); // Focus menu item\n\n        triggerAccessibilityOpen(parentKey, false);\n        tryFocus(parentMenuElement);\n      }\n    } // Pass origin key down event\n\n\n    originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e);\n  };\n}","map":{"version":3,"sources":["/Users/liuyang/Documents/yideng/jira/node_modules/rc-menu/lib/hooks/useAccessibility.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","Object","defineProperty","exports","value","default","useAccessibility","_defineProperty2","React","_KeyCode","_raf","_focus","_IdContext","LEFT","RIGHT","UP","DOWN","ENTER","ESC","ArrowKeys","getOffset","mode","isRootLevel","isRtl","which","_inline","_horizontal","_vertical","_offsets$","prev","next","children","parent","inlineTrigger","inline","horizontal","vertical","offsets","inlineSub","horizontalSub","verticalSub","type","concat","offset","sibling","findContainerUL","element","current","getAttribute","parentElement","getFocusElement","activeElement","elements","document","has","getFocusableElements","container","list","getFocusNodeList","filter","ele","getNextFocusElement","parentQueryContainer","focusMenuElement","arguments","length","undefined","sameLevelFocusableMenuElementList","count","focusIndex","findIndex","activeKey","id","containerRef","getKeys","getKeyPath","triggerActiveKey","triggerAccessibilityOpen","originOnKeyDown","rafRef","useRef","activeRef","cleanRaf","cancel","useEffect","e","includes","key2element","element2key","refreshElements","Set","Map","keys","forEach","key","querySelector","getMenuId","add","set","get","focusMenuKey","offsetObj","preventDefault","tryFocus","menuElement","focusTargetElement","link","targetKey","focus","targetElement","controlId","subQueryContainer","getElementById","keyPath","parentKey","parentMenuElement"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useAccessibility;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _KeyCode = _interopRequireDefault(require(\"rc-util/lib/KeyCode\"));\n\nvar _raf = _interopRequireDefault(require(\"rc-util/lib/raf\"));\n\nvar _focus = require(\"rc-util/lib/Dom/focus\");\n\nvar _IdContext = require(\"../context/IdContext\");\n\n// destruct to reduce minify size\nvar LEFT = _KeyCode.default.LEFT,\n    RIGHT = _KeyCode.default.RIGHT,\n    UP = _KeyCode.default.UP,\n    DOWN = _KeyCode.default.DOWN,\n    ENTER = _KeyCode.default.ENTER,\n    ESC = _KeyCode.default.ESC;\nvar ArrowKeys = [UP, DOWN, LEFT, RIGHT];\n\nfunction getOffset(mode, isRootLevel, isRtl, which) {\n  var _inline, _horizontal, _vertical, _offsets$;\n\n  var prev = 'prev';\n  var next = 'next';\n  var children = 'children';\n  var parent = 'parent'; // Inline enter is special that we use unique operation\n\n  if (mode === 'inline' && which === ENTER) {\n    return {\n      inlineTrigger: true\n    };\n  }\n\n  var inline = (_inline = {}, (0, _defineProperty2.default)(_inline, UP, prev), (0, _defineProperty2.default)(_inline, DOWN, next), _inline);\n  var horizontal = (_horizontal = {}, (0, _defineProperty2.default)(_horizontal, LEFT, isRtl ? next : prev), (0, _defineProperty2.default)(_horizontal, RIGHT, isRtl ? prev : next), (0, _defineProperty2.default)(_horizontal, DOWN, children), (0, _defineProperty2.default)(_horizontal, ENTER, children), _horizontal);\n  var vertical = (_vertical = {}, (0, _defineProperty2.default)(_vertical, UP, prev), (0, _defineProperty2.default)(_vertical, DOWN, next), (0, _defineProperty2.default)(_vertical, ENTER, children), (0, _defineProperty2.default)(_vertical, ESC, parent), (0, _defineProperty2.default)(_vertical, LEFT, isRtl ? children : parent), (0, _defineProperty2.default)(_vertical, RIGHT, isRtl ? parent : children), _vertical);\n  var offsets = {\n    inline: inline,\n    horizontal: horizontal,\n    vertical: vertical,\n    inlineSub: inline,\n    horizontalSub: vertical,\n    verticalSub: vertical\n  };\n  var type = (_offsets$ = offsets[\"\".concat(mode).concat(isRootLevel ? '' : 'Sub')]) === null || _offsets$ === void 0 ? void 0 : _offsets$[which];\n\n  switch (type) {\n    case prev:\n      return {\n        offset: -1,\n        sibling: true\n      };\n\n    case next:\n      return {\n        offset: 1,\n        sibling: true\n      };\n\n    case parent:\n      return {\n        offset: -1,\n        sibling: false\n      };\n\n    case children:\n      return {\n        offset: 1,\n        sibling: false\n      };\n\n    default:\n      return null;\n  }\n}\n\nfunction findContainerUL(element) {\n  var current = element;\n\n  while (current) {\n    if (current.getAttribute('data-menu-list')) {\n      return current;\n    }\n\n    current = current.parentElement;\n  } // Normally should not reach this line\n\n  /* istanbul ignore next */\n\n\n  return null;\n}\n/**\n * Find focused element within element set provided\n */\n\n\nfunction getFocusElement(activeElement, elements) {\n  var current = activeElement || document.activeElement;\n\n  while (current) {\n    if (elements.has(current)) {\n      return current;\n    }\n\n    current = current.parentElement;\n  }\n\n  return null;\n}\n/**\n * Get focusable elements from the element set under provided container\n */\n\n\nfunction getFocusableElements(container, elements) {\n  var list = (0, _focus.getFocusNodeList)(container, true);\n  return list.filter(function (ele) {\n    return elements.has(ele);\n  });\n}\n\nfunction getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n  // Key on the menu item will not get validate parent container\n  if (!parentQueryContainer) {\n    return null;\n  } // List current level menu item elements\n\n\n  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements); // Find next focus index\n\n  var count = sameLevelFocusableMenuElementList.length;\n  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function (ele) {\n    return focusMenuElement === ele;\n  });\n\n  if (offset < 0) {\n    if (focusIndex === -1) {\n      focusIndex = count - 1;\n    } else {\n      focusIndex -= 1;\n    }\n  } else if (offset > 0) {\n    focusIndex += 1;\n  }\n\n  focusIndex = (focusIndex + count) % count; // Focus menu item\n\n  return sameLevelFocusableMenuElementList[focusIndex];\n}\n\nfunction useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {\n  var rafRef = React.useRef();\n  var activeRef = React.useRef();\n  activeRef.current = activeKey;\n\n  var cleanRaf = function cleanRaf() {\n    _raf.default.cancel(rafRef.current);\n  };\n\n  React.useEffect(function () {\n    return function () {\n      cleanRaf();\n    };\n  }, []);\n  return function (e) {\n    var which = e.which;\n\n    if ([].concat(ArrowKeys, [ENTER, ESC]).includes(which)) {\n      // Convert key to elements\n      var elements;\n      var key2element;\n      var element2key; // >>> Wrap as function since we use raf for some case\n\n      var refreshElements = function refreshElements() {\n        elements = new Set();\n        key2element = new Map();\n        element2key = new Map();\n        var keys = getKeys();\n        keys.forEach(function (key) {\n          var element = document.querySelector(\"[data-menu-id='\".concat((0, _IdContext.getMenuId)(id, key), \"']\"));\n\n          if (element) {\n            elements.add(element);\n            element2key.set(element, key);\n            key2element.set(key, element);\n          }\n        });\n        return elements;\n      };\n\n      refreshElements(); // First we should find current focused MenuItem/SubMenu element\n\n      var activeElement = key2element.get(activeKey);\n      var focusMenuElement = getFocusElement(activeElement, elements);\n      var focusMenuKey = element2key.get(focusMenuElement);\n      var offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which); // Some mode do not have fully arrow operation like inline\n\n      if (!offsetObj) {\n        return;\n      } // Arrow prevent default to avoid page scroll\n\n\n      if (ArrowKeys.includes(which)) {\n        e.preventDefault();\n      }\n\n      var tryFocus = function tryFocus(menuElement) {\n        if (menuElement) {\n          var focusTargetElement = menuElement; // Focus to link instead of menu item if possible\n\n          var link = menuElement.querySelector('a');\n\n          if (link === null || link === void 0 ? void 0 : link.getAttribute('href')) {\n            focusTargetElement = link;\n          }\n\n          var targetKey = element2key.get(menuElement);\n          triggerActiveKey(targetKey);\n          /**\n           * Do not `useEffect` here since `tryFocus` may trigger async\n           * which makes React sync update the `activeKey`\n           * that force render before `useRef` set the next activeKey\n           */\n\n          cleanRaf();\n          rafRef.current = (0, _raf.default)(function () {\n            if (activeRef.current === targetKey) {\n              focusTargetElement.focus();\n            }\n          });\n        }\n      };\n\n      if (offsetObj.sibling || !focusMenuElement) {\n        // ========================== Sibling ==========================\n        // Find walkable focus menu element container\n        var parentQueryContainer;\n\n        if (!focusMenuElement || mode === 'inline') {\n          parentQueryContainer = containerRef.current;\n        } else {\n          parentQueryContainer = findContainerUL(focusMenuElement);\n        } // Get next focus element\n\n\n        var targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset); // Focus menu item\n\n        tryFocus(targetElement); // ======================= InlineTrigger =======================\n      } else if (offsetObj.inlineTrigger) {\n        // Inline trigger no need switch to sub menu item\n        triggerAccessibilityOpen(focusMenuKey); // =========================== Level ===========================\n      } else if (offsetObj.offset > 0) {\n        triggerAccessibilityOpen(focusMenuKey, true);\n        cleanRaf();\n        rafRef.current = (0, _raf.default)(function () {\n          // Async should resync elements\n          refreshElements();\n          var controlId = focusMenuElement.getAttribute('aria-controls');\n          var subQueryContainer = document.getElementById(controlId); // Get sub focusable menu item\n\n          var targetElement = getNextFocusElement(subQueryContainer, elements); // Focus menu item\n\n          tryFocus(targetElement);\n        }, 5);\n      } else if (offsetObj.offset < 0) {\n        var keyPath = getKeyPath(focusMenuKey, true);\n        var parentKey = keyPath[keyPath.length - 2];\n        var parentMenuElement = key2element.get(parentKey); // Focus menu item\n\n        triggerAccessibilityOpen(parentKey, false);\n        tryFocus(parentMenuElement);\n      }\n    } // Pass origin key down event\n\n\n    originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e);\n  };\n}"]},"metadata":{},"sourceType":"script"}